<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>SEBE Template</title>
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-fl.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.overrides.css">
</head>
<!-- ------------------------------------------- -->
<body class="cloudFirst">
<h1>Data Wrangling: Join, Combine, divide and Reshape</h1>
<!-- ------------------------------------------- -->
<h2></h2>
<p></p>
<h2><span style="color: #990000;"><b>Combining and Merging Datasets</b></span></h2>
<p>Data contained in pandas&nbsp;objects can be combined together in a number of ways:</p>
<ul type="disc">
<li><em><strong>pandas.merge</strong></em>&nbsp;connects rows in DataFrames based on one or more keys. This will be familiar to users of SQL or other relational databases, as it implements database&nbsp;<em><strong>join&nbsp;</strong></em>operations.</li>
<li><em><strong>pandas.concat</strong></em>&nbsp;concatenates&nbsp;or &ldquo;stacks&rdquo; together objects along an axis.</li>
<li>The&nbsp;<em><strong>combine_first</strong></em>&nbsp;instance&nbsp;method enables splicing together overlapping data to fill in missing values in one object with values from another.</li>
</ul>
<p></p>
<h2>Database-Style DataFrame Joins</h2>
<p><strong><i>Merge</i>&nbsp;</strong>or&nbsp;<strong><i>join</i></strong>&nbsp;operations&nbsp;combine datasets by linking rows using one or more&nbsp;<em><strong>keys</strong></em>. These operations are central to relational databases (e.g., SQL-based). The&nbsp;merge&nbsp;function&nbsp;in pandas is the main entry point for using these algorithms on your data.</p>
<p>Let&rsquo;s start with a simple example:</p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>In [35]: df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],<br /> ....: 'data1': range(7)})</p>
<p>In [36]: df2 = pd.DataFrame({'key': ['a', 'b', 'd'],<br /> ....: 'data1': range(3)})</p>
<p>In [37]: df1<br />Out[37]: <br /> data1 key<br />0 0 b<br />1 1 b<br />2 2 a<br />3 3 c<br />4 4 a<br />5 5 a<br />6 6 b</p>
<p>In [38]: df2<br />Out[38]: <br /> data2 key<br />0 0 a<br />1 1 b<br />2 2 d</p>
</div>
<p><em><strong>merge&nbsp;</strong></em>uses the overlapping column names as the keys.</p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>In [40]: pd.merge(df1, df2, on='key')<br />Out[40]: <br /> key data1_x data1_y<br />0 b 0 1<br />1 b 1 1<br />2 b 6 1<br />3 a 2 0<br />4 a 4 0<br />5 a 5 0</p>
</div>
<p>The <em><strong>concat()</strong></em>&nbsp;function will perform concatenation operations along an axis on two data frames. For the above example, it will be:</p>
<p></p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>pd.concat([df1,df2],axis=0)<br />Out[108]: <br /> key data1<br />0 b 0<br />1 b 1<br />2 a 2<br />3 c 3<br />4 a 4<br />5 a 5<br />6 b 6<br />0 a 0<br />1 b 1<br />2 d 2</p>
</div>
<p></p>
<h2><span style="color: #990000;"><b>Slicing a Dataset</b></span></h2>
<p><span style="color: #000000;"><strong></strong></span>We can select specific ranges of our data in both the row and column directions using either label or integer-based indexing.</p>
<ul type="disc">
<li>loc&nbsp;is primarily&nbsp;<i>label</i>&nbsp;based indexing.&nbsp;<i>Integers</i>&nbsp;may be used but they are interpreted as a&nbsp;<i>label</i>.</li>
<li>iloc&nbsp;is primarily&nbsp;<i>integer</i>&nbsp;based indexing</li>
</ul>
<p>To select a subset of rows&nbsp;<b>and</b>&nbsp;columns from our DataFrame, we can use the&nbsp;iloc&nbsp;method. For example,&nbsp;let&rsquo;s create a data frame as below:</p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>df1 = pd.DataFrame({'key': ['a', 'a', 'a', 'a', 'b', 'b', 'b'], 'data1': range(7)})<br />It produces:<br />Out[117]: <br /> key data1<br />0 a 0<br />1 a 1<br />2 a 2<br />3 a 3<br />4 b 4<br />5 b 5<br />6 b 6</p>
</div>
<p>Now we want to divide into two data frames where the first 4 rows (key=&rsquo;a&rsquo;) will be in one data frame and the remaining are in the second one. Follow the code below that uses <i>iloc.</i></p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>df_a=df1.iloc[0:4]</p>
<p>df_a<br />Out[130]: <br /> key data1<br />0 a 0<br />1 a 1<br />2 a 2<br />3 a 3</p>
<p>df_b=df1.iloc[4:]</p>
<p>df_b<br />Out[132]: <br /> key data1<br />4 b 4<br />5 b 5<br />6 b 6</p>
</div>
<h2></h2>
<h2><strong><span style="color: #990000;">Reshaping</span></strong></h2>
<p>There are a number of basic operations for rearranging tabular data. These are alternatingly referred to as&nbsp;<em><strong>reshape&nbsp;</strong></em>or&nbsp;<strong><i>pivot</i>&nbsp;</strong>operations.</p>
<p></p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>data = pd.DataFrame(np.arange(6).reshape((2, 3)), index=pd.Index(['Ohio', 'Colorado'], name='state'), columns=pd.Index(['one', 'two', 'three'], name='number'))</p>
<p>data<br />Out[136]: <br />number one two three<br />state <br />Ohio 0 1 2<br />Colorado 3 4 5</p>
</div>
<p>Here we are using numpy data series to generate a series of number 1,2,3,4,5, and 6 and reshaping in a 2 row 3 column tabular form.</p>
<p></p>
<p></p>
</body>
<script defer type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-master.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.js"></script>

<script  type="text/javascript">
function localFunction(){

  console.log("");
  console.log("ready!");

 
  /* ------------------------------------------------ */  
  /* -- START: PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  var p = Prism.languages;
  var languagesArray = new Array();

  // iterate over elements in Prism.languages
  console.log("")
  console.log("Iterating over Prism.languages object...");
  for (var key in p) {
    if (p.hasOwnProperty(key)) {
      // if an element is a function, ignore it
      if ( p[key] instanceof Function ) {
        console.log("found function: " + key);
      } else {
        // otherwise if it's an object, count it as language
        languagesArray.push(key);
      }
    }
  }
  console.log("");

  var languagesString = "";
  var counter = 0;
  console.log("Found " + languagesArray.length + " languages in the Prism.languages object");
  languagesArray.sort().forEach(function (language) {
    languagesString += language;
    if(++counter < languagesArray.length) {
      languagesString += ", ";
    }
  });

  console.log("List of languages available:");
  console.log("--------------------------------------");
  console.log(languagesString);
  console.log("--------------------------------------");
  /* -- END:   PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  /* ------------------------------------------------ */  

  $('#viewTranscript').click(function(){
    if($('#viewTranscript').text() == 'View transcript') {
      $('#transcript-en').show();
      $('#viewTranscript').text('Close transcript');
    } else {
      $('#transcript-en').hide();
      $('#viewTranscript').text('View transcript');
    }
  });
 
  /* Just need 3 things in the markup: 1. href="#video1", 2. class="transcript__timestamp" and 3. the timestamp value eg. 2:47  */
 $(".transcript__timestamp").click(function(){

    //collect video id and time attributes

      //var thisID = $(this).attr('id');
      var thisHref = $(this).attr('href');
      //the href is an id but will strp the # of it in case that's not always what the id is. Thsi hash can be added back oin the global func
      thisHref = thisHref.substring(1);
      //console.log(thisHref);
      var thisTimsStr = $(this).text();

      //thisTimsStr may have extra text after the actual time so to make sure, it needs to be stripped out.
      var n = thisTimsStr.indexOf(":")+3;
      var stripped = thisTimsStr.substring(0, n);
      //console.log('stripped '+ stripped);
      //now convert to seconds
      var split = stripped.split(':');
      //console.log(split);
      var thisTime = (split[0] * 60) + parseInt(split[1]);
      console.log('thisHref is ' + thisHref + ' thisTime is ' + thisTime);
      videoJumpToTime(thisHref,thisTime)
  });

MathJax.Hub.Config({

  "HTML-CSS": {
      scale: 100
   }
});
 
}
</script>
</html>