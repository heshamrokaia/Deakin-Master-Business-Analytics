<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>SEBE Template</title>
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-fl.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.overrides.css">
</head>
<!-- ------------------------------------------- -->
<body class="cloudFirst">
<h1>Machine Learning in Security Analysis: An Example (Part 1)</h1>
<!-- ------------------------------------------- -->
<h2><span style="color: #cf2a27;">&nbsp;</span></h2>
<p></p>
<!-- ------------------------------------------- -->
<h2><b>Part 1: Importing and understanding the dataset</b></h2>
<p>Let&rsquo;s see how machine learning can help in security analysis on a dataset. Here we are going to use a simple &ldquo;payment fraud&rdquo; dataset. The dataset that we are using is transaction data for online purchases collected from an eCommerce retailer.</p>
<p>You can access the dataset from the "Weekly Datasets and Codes" as well as from the VM provided to you under week 3 learning resources.</p>
<p>The dataset contains 39,221 transactions, each comprising 5 properties that can be used to describe the transaction, as well as a binary &ldquo;label&rdquo; indicating whether this transaction is an instance of fraud&mdash;&ldquo;1&rdquo; if fraudulent, and &ldquo;0&rdquo; if not. The comma-separated values (CSV) format that this data is in is a standard way of representing data for analytics.</p>
<p><i></i></p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>import pandas as pd<br />from sklearn.metrics import confusion_matrix<br />dfp = pd.read_csv('payment_fraud.csv')</p>
</div>
<p>Once you run the above commands, the dataset is imported. To check it, click on the variable explorer and double click on the dfp dataframe. You will be able to see the dataframe as below:</p>
<p><img src="PastedImage_g6825gzohvvqhk00kovc4nunsj24ybbc001117903778.png" data-d2l-editor-default-img-style="true" style="max-width: 100%;" /></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h5></h5>
<p>Here you can see the five properties &ldquo;AccountAgeDays&rdquo;, &ldquo;numItems&rdquo;, &ldquo;localTime&rdquo;, &ldquo;paymentMethod&ldquo;, &ldquo;paymentMethodAgeDays&rdquo; and &ldquo;label&rdquo;. Index 109 corresponds to &ldquo;1&rdquo; in label column. That means, it is <i>fraudulent </i>transactions. The other labeled as &ldquo;0&rdquo; represents <i>normal</i> (NOT <i>fraudulent</i>).</p>
<p>Note that one column stands out because it is of non-numerical type:&nbsp;&ldquo;paymentMethod&rdquo;. There are three possible values that this feature takes on in our dataset:&nbsp;<i>creditcard</i>,&nbsp;<i>paypal</i>, and&nbsp;<i>storecredit</i>.&nbsp;This feature is called a&nbsp;<i>categorical variable</i>&nbsp;because it takes on a value indicating the category it belongs to. Many machine learning algorithms require all features to be <i>numeric</i>.&nbsp;We can use&nbsp;<a href="http://bit.ly/2DaCzfU">pandas.get_dummies()</a>&nbsp;to convert variables from categorical to numeric.</p>
<div style="background: #f8f8f8; padding: 12pt; border: 1pt solid #cccccc;">
<p>df = pd.get_dummies(dfp, columns=['paymentMethod'])</p>
</div>
<p>Upon inspection of the new DataFrame object, we notice that three new columns have been added to the table&mdash;<i>paymentMethod_creditcard</i>,&nbsp;<i>paymentMethod_paypal</i>, and&nbsp;<i>paymentMethod_storecredit</i>:</p>
<p><img src="PastedImage_lgcxhihryatg02b4eb2lchxq8knekpa3001117903778.png" data-d2l-editor-default-img-style="true" style="max-width: 100%;" /></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h5></h5>
<p>Each of these features is a binary feature (i.e., they take on a value of either 0 or 1), and each row has exactly one of these features set to 1, hence the name of this method of categorical variable encoding:&nbsp;<i>one-hot encoding</i>.&nbsp;These variables are called&nbsp;<i>dummy variables</i>&nbsp;in statistics terminology.</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</body>
<script defer type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-master.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.js"></script>

<script  type="text/javascript">
function localFunction(){

  console.log("");
  console.log("ready!");

 
  /* ------------------------------------------------ */  
  /* -- START: PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  var p = Prism.languages;
  var languagesArray = new Array();

  // iterate over elements in Prism.languages
  console.log("")
  console.log("Iterating over Prism.languages object...");
  for (var key in p) {
    if (p.hasOwnProperty(key)) {
      // if an element is a function, ignore it
      if ( p[key] instanceof Function ) {
        console.log("found function: " + key);
      } else {
        // otherwise if it's an object, count it as language
        languagesArray.push(key);
      }
    }
  }
  console.log("");

  var languagesString = "";
  var counter = 0;
  console.log("Found " + languagesArray.length + " languages in the Prism.languages object");
  languagesArray.sort().forEach(function (language) {
    languagesString += language;
    if(++counter < languagesArray.length) {
      languagesString += ", ";
    }
  });

  console.log("List of languages available:");
  console.log("--------------------------------------");
  console.log(languagesString);
  console.log("--------------------------------------");
  /* -- END:   PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  /* ------------------------------------------------ */  

  $('#viewTranscript').click(function(){
    if($('#viewTranscript').text() == 'View transcript') {
      $('#transcript-en').show();
      $('#viewTranscript').text('Close transcript');
    } else {
      $('#transcript-en').hide();
      $('#viewTranscript').text('View transcript');
    }
  });
 
  /* Just need 3 things in the markup: 1. href="#video1", 2. class="transcript__timestamp" and 3. the timestamp value eg. 2:47  */
 $(".transcript__timestamp").click(function(){

    //collect video id and time attributes

      //var thisID = $(this).attr('id');
      var thisHref = $(this).attr('href');
      //the href is an id but will strp the # of it in case that's not always what the id is. Thsi hash can be added back oin the global func
      thisHref = thisHref.substring(1);
      //console.log(thisHref);
      var thisTimsStr = $(this).text();

      //thisTimsStr may have extra text after the actual time so to make sure, it needs to be stripped out.
      var n = thisTimsStr.indexOf(":")+3;
      var stripped = thisTimsStr.substring(0, n);
      //console.log('stripped '+ stripped);
      //now convert to seconds
      var split = stripped.split(':');
      //console.log(split);
      var thisTime = (split[0] * 60) + parseInt(split[1]);
      console.log('thisHref is ' + thisHref + ' thisTime is ' + thisTime);
      videoJumpToTime(thisHref,thisTime)
  });

MathJax.Hub.Config({

  "HTML-CSS": {
      scale: 100
   }
});
 
}
</script>
</html>