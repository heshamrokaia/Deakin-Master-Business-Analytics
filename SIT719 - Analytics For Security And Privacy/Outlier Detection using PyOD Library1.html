<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>SEBE Template</title>
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-fl.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.css">
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.overrides.css">
</head>
<!-- ------------------------------------------- -->
<body class="cloudFirst">
<h1>Outlier Detection using PyOD Library</h1>
<!-- ------------------------------------------- -->
<h2><span style="color: #cf2a27;">&nbsp;</span></h2>
<p>Outlier detection broadly refers to the task of identifying observations which may be considered anomalous given the distribution of a sample. Any observation belonging to the distribution is referred to as an inlier and any outlying point is referred to as an outlier.</p>
<p>In the context of unsupervised machine learning, the&nbsp;following two processes are widely used:</p>
<ol>
<li><b>Unsupervised Outlier Detection</b></li>
</ol>
<ul>
<li style="list-style: none;">
<ul>
<li>Training data (unlabelled) contains both normal and anomalous observations.</li>
<li>The model identifies outliers during the fitting process.</li>
<li>This approach is taken when outliers are defined as points that exist in low-density regions in the data.</li>
<li>Any new observations that do not belong to high-density regions are considered outliers.</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<ol start="2">
<li><b>Semi-supervised Novelty Detection</b></li>
</ol>
<ul>
<li style="list-style: none;">
<ul>
<li>Training data consists only of observations describing normal behavior.</li>
<li>The model is fit on training data and then used to evaluate new observations.</li>
<li>This approach is taken when outliers are defined as points differing from the distribution of the training data.</li>
<li>Any new observations differing from the training data within a threshold, even if they form a high-density region, are considered outliers.</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;We will explore some outlier detection algorithms that can be implemented using PyOD.</p>
<p>&nbsp;</p>
<h3>Angle-Based Outlier Detection (ABOD)</h3>
<ul type="disc">
<li>It considers the relationship between each point and its neighbor(s).&nbsp;<em>It does not consider the relationships among these neighbors.</em>&nbsp;The variance of its weighted cosine scores to all neighbors could be viewed as the outlying score.<br /> </li>
<li>ABOD performs well on multi-dimensional data</li>
<li>PyOD provides two different versions of ABOD:</li>
<ul type="circle">
<li><strong>Fast ABOD:</strong>&nbsp;Uses k-nearest neighbors to approximate</li>
<li><strong>Original ABOD:</strong>&nbsp;Considers all training points with high-time complexity</li>
</ul>
</ul>
<p>&nbsp;</p>
<h3>k-Nearest Neighbors Detector</h3>
<ul type="disc">
<li>For any data point, the distance to its kth nearest neighbor could be viewed as the outlying score</li>
<li>PyOD supports three&nbsp;<a href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/">kNN</a>&nbsp;detectors:</li>
<ul type="circle">
<li><strong>Largest:</strong>&nbsp;Uses the distance of the kth neighbor as the outlier score</li>
<li><strong>Mean:</strong>&nbsp;Uses the average of all k neighbors as the outlier score</li>
<li><strong>Median:</strong>&nbsp;Uses the median of the distance to k neighbors as the outlier score</li>
</ul>
</ul>
<p>&nbsp;</p>
<h3>Isolation Forest</h3>
<ul type="disc">
<li>It uses the scikit-learn library internally. In this method, data partitioning is done using a set of trees. Isolation Forest provides an anomaly score looking at how isolated the point is in the structure. The anomaly score is then used to identify outliers from normal observations</li>
<li>Isolation Forest performs well on multi-dimensional data</li>
</ul>
<p>&nbsp;</p>
<h3>Histogram-based Outlier Detection</h3>
<ul type="disc">
<li>It is an efficient unsupervised method which assumes the feature independence and calculates the outlier score by building histograms</li>
<li>It is much faster than multivariate approaches, but at the cost of less precision.</li>
</ul>
<p>&nbsp;</p>
<h3>Local Correlation Integral (LOCI)</h3>
<ul type="disc">
<li>LOCI is very effective for detecting outliers and groups of outliers. It provides a LOCI plot for each point which summarizes a lot of the information about the data in the area around the point, determining clusters, micro-clusters, their diameters, and their inter-cluster distances</li>
<li>None of the existing outlier-detection methods can match this feature because they output only a single number for each point</li>
</ul>
<p>&nbsp;</p>
<h3>Feature Bagging</h3>
<ul type="disc">
<li>A feature bagging detector fits a number of base detectors on various sub-samples of the dataset. It uses averaging or other combination methods to improve the prediction accuracy</li>
<li>By default, Local Outlier Factor (LOF) is used as the base estimator. However, any estimator could be used as the base estimator, such as kNN and ABOD</li>
<li>Feature bagging first constructs&nbsp;<em>n</em>&nbsp;sub-samples by randomly selecting a subset of features. This brings out the diversity of base estimators. Finally, the prediction score is generated by averaging or taking the maximum of all base detectors</li>
</ul>
<p>&nbsp;</p>
<h3>Clustering Based Local Outlier Factor</h3>
<ul type="disc">
<li>It classifies the data into small clusters and large clusters. The anomaly score is then calculated based on the size of the cluster the point belongs to, as well as the distance to the nearest large cluster</li>
</ul>
<p>&nbsp;</p>
</body>
<script defer type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-master.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/open-source-css-and-js/prism/prism.js"></script>

<script  type="text/javascript">
function localFunction(){

  console.log("");
  console.log("ready!");

 
  /* ------------------------------------------------ */  
  /* -- START: PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  var p = Prism.languages;
  var languagesArray = new Array();

  // iterate over elements in Prism.languages
  console.log("")
  console.log("Iterating over Prism.languages object...");
  for (var key in p) {
    if (p.hasOwnProperty(key)) {
      // if an element is a function, ignore it
      if ( p[key] instanceof Function ) {
        console.log("found function: " + key);
      } else {
        // otherwise if it's an object, count it as language
        languagesArray.push(key);
      }
    }
  }
  console.log("");

  var languagesString = "";
  var counter = 0;
  console.log("Found " + languagesArray.length + " languages in the Prism.languages object");
  languagesArray.sort().forEach(function (language) {
    languagesString += language;
    if(++counter < languagesArray.length) {
      languagesString += ", ";
    }
  });

  console.log("List of languages available:");
  console.log("--------------------------------------");
  console.log(languagesString);
  console.log("--------------------------------------");
  /* -- END:   PRISM JS PRINT LANGUAGES TO CONSOLE -- */
  /* ------------------------------------------------ */  

  $('#viewTranscript').click(function(){
    if($('#viewTranscript').text() == 'View transcript') {
      $('#transcript-en').show();
      $('#viewTranscript').text('Close transcript');
    } else {
      $('#transcript-en').hide();
      $('#viewTranscript').text('View transcript');
    }
  });
 
  /* Just need 3 things in the markup: 1. href="#video1", 2. class="transcript__timestamp" and 3. the timestamp value eg. 2:47  */
 $(".transcript__timestamp").click(function(){

    //collect video id and time attributes

      //var thisID = $(this).attr('id');
      var thisHref = $(this).attr('href');
      //the href is an id but will strp the # of it in case that's not always what the id is. Thsi hash can be added back oin the global func
      thisHref = thisHref.substring(1);
      //console.log(thisHref);
      var thisTimsStr = $(this).text();

      //thisTimsStr may have extra text after the actual time so to make sure, it needs to be stripped out.
      var n = thisTimsStr.indexOf(":")+3;
      var stripped = thisTimsStr.substring(0, n);
      //console.log('stripped '+ stripped);
      //now convert to seconds
      var split = stripped.split(':');
      //console.log(split);
      var thisTime = (split[0] * 60) + parseInt(split[1]);
      console.log('thisHref is ' + thisHref + ' thisTime is ' + thisTime);
      videoJumpToTime(thisHref,thisTime)
  });

MathJax.Hub.Config({

  "HTML-CSS": {
      scale: 100
   }
});
 
}
</script>
</html>