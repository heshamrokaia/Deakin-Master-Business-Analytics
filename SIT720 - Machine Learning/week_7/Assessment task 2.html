<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager --><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager --><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CloudDeakin Dual Delivery Template</title>
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-fl.css">
  <link rel="stylesheet" type="text/css" href="../00-assets/navbar/navbar-parent.css">
<link rel="stylesheet" type="text/css" href="../00-assets/css/sit307-720.css">

</head><body style="color: rgb(32, 33, 34); font-family: verdana, sans-serif; font-size: 10px;"><p><img src="../images/SVM%20formulation%20and%20solution%20for%20linearly%20separable%20data%20image%201.jpg" alt="3db ackground abstract and shape with colorful" title="3db ackground abstract and shape with colorful" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
<address><a href="https://www.gettyimages.com.au" target="_blank" rel="noopener noreferrer">© Getty Images</a></address>
<div>
<h1>SVM formulation and solution for linearly separable data=</h1>
</div>
<div>
<p>SVM aims to find a hyperplane&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\((\textbf{w},b)\)"}</annotation></semantics></math>&nbsp;so that the margin&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mfrac><mn>2</mn><mrow><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mo fence="false" stretchy="false">∥<!-- ∥ --></mo></mrow></mfrac></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\frac{2}{\|\textbf{w}\|}\)"}</annotation></semantics></math>&nbsp;is maximised while satisfying the constraint&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mi>T</mi></msup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥<!-- ≥ --></mo><mn>1</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(y_i(\textbf{w}^T\textbf{x}_i+b) \geq 1\)"}</annotation></semantics></math>.</p>
<p>The SVM formulation therefore solves the following optimisation problem:</p>
<p><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mspace linebreak="newline"></mspace><mi>M</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>e</mi><mtext>&nbsp;</mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><msup><mo>∥<!-- ∥ --></mo><mn>2</mn></msup><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>s</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>t</mi><mi>o</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mi>T</mi></msup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥<!-- ≥ --></mo><mn>1</mn><mspace width="1em"></mspace><mi mathvariant="normal">∀<!-- ∀ --></mi><mi>i</mi><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\\ Minimise \ \frac{1}{2} \|\textbf{w}\|^2 \\ \\ subject\ to\ \ y_i(\textbf{w}^T\textbf{x}_i + b) \geq 1 \quad \forall i \\\)"}</annotation></semantics></math></p>
<p>Remember the problem of maximising&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mfrac><mn>2</mn><mrow><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mo fence="false" stretchy="false">∥<!-- ∥ --></mo></mrow></mfrac></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\frac{2}{\|\textbf{w}\|}\)"}</annotation></semantics></math>&nbsp;is the same as minimising&nbsp;&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><msup><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><mn>2</mn></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\frac{1}{2} \|\textbf{w}\|^2\)"}</annotation></semantics></math>.&nbsp;&nbsp;We need to optimise a&nbsp;<em>quadratic function</em>&nbsp;in&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>w</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(w\)"}</annotation></semantics></math>&nbsp;subject to&nbsp;<em>linear constraints</em>.</p>
<p>This problem is well known in the optimisation community and is called&nbsp;<em>quadratic programming</em>.&nbsp;<strong>Do not get confused with the word&nbsp;<em>programming</em></strong>. It just means optimisation. The optimisation problem is often solved by constructing an equivalent problem called a&nbsp;<em>dual problem</em>.</p>
<p>In quadratic programming, the original optimisation problem is called the&nbsp;<em>primal problem</em>. The solution to the dual problem provides a lower bound to the solution of the primal (minimisation) problem.</p>
<h3 id="dual-optimisation-problem">Dual optimisation problem</h3>
<p>Remember, the&nbsp;<em>primal problem</em>&nbsp;in SVM which is maximising the&nbsp;<em>margin</em>&nbsp;(or minimising&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mfrac><mn>1</mn><mrow><mi>m</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\frac{1}{margin}\)"}</annotation></semantics></math>.&nbsp;</p>
<p><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mspace linebreak="newline"></mspace><mi>M</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>z</mi><mi>e</mi><mtext>&nbsp;</mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><msup><mo>∥<!-- ∥ --></mo><mn>2</mn></msup><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>s</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>t</mi><mi>o</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mi>T</mi></msup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥<!-- ≥ --></mo><mn>1</mn><mspace width="1em"></mspace><mi mathvariant="normal">∀<!-- ∀ --></mi><mi>i</mi><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\\ Minimize \ \frac{1}{2} \|\textbf{w}\|^2 \\ \\ subject\ to\ \ y_i(\textbf{w}^T\textbf{x}_i + b) \geq 1 \quad \forall i \\"}</annotation></semantics></math></p>
<p>Using Lagrange multipliers we can convert a constrained optimisation into an unconstrained optimisation problem. Lagrange multipliers is a strategy for finding the local maxima and minima of a function subject to equality constraints. The Lagrange function to minimise is where&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>α<!-- α --></mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>α<!-- α --></mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>α<!-- α --></mi><mi>n</mi></msub><mo stretchy="false">]</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha = [\alpha_1,...,\alpha_n]\)"}</annotation></semantics></math>&nbsp;are Lagrange multipliers:</p>
<p><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mspace linebreak="newline"></mspace><mi>L</mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mo>,</mo><mi>b</mi><mo>,</mo><mi>α<!-- α --></mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><msup><mo>∥<!-- ∥ --></mo><mn>2</mn></msup><mo>+</mo><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>−<!-- − --></mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mi>T</mi></msup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\\ L(\textbf{w},b,\alpha) = \frac{1}{2} \|\textbf{w}\|^2 + \sum_{i=1}^{n} \alpha_i(1-y_i(\textbf{w}^T\textbf{x}_i + b)) \\"}</annotation></semantics></math>&nbsp;Now we have a function to maximise, so by setting the derivative (with respect to&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{w}\)"}</annotation></semantics></math>)&nbsp;to zero and substituting the results in Lagrange function, we get the dual formulation (dual problem):</p>
<p><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mspace linebreak="newline"></mspace><munder><mo movablelimits="true" form="prefix">min</mo><mrow class="MJX-TeXAtom-ORD"><mi>α<!-- α --></mi></mrow></munder><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><mo>−<!-- − --></mo><mfrac><mn>1</mn><mn>2</mn></mfrac><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>α<!-- α --></mi><mi>j</mi></msub><msub><mi>y</mi><mi>i</mi></msub><msub><mi>y</mi><mi>j</mi></msub><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>s</mi><mi>u</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>t</mi><mi>o</mi><mo>:</mo><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><msub><mi>α<!-- α --></mi><mi>i</mi></msub><mo>≥<!-- ≥ --></mo><mn>0</mn><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>l</mi><mtext>&nbsp;</mtext><mi>i</mi><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\\ \min_{\alpha} \sum_{i=1}^{n} \alpha_i - \frac{1}{2} \sum_{i=1}^{n}\sum_{i=1}^{n} \alpha_i\alpha_j y_i y_j \textbf{x}_i^T \textbf{x}_j \\ \\ subject\ \ to: \sum_{i=1}^{n} \alpha_i y_i = 0 \ \ and \ \ \alpha_i \geq 0 \ \ for \ all \ i \\"}</annotation></semantics></math></p>
<p>If you carefully look at the derived problem, you can see that&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_i\)"}</annotation></semantics></math>&nbsp;and&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_j\)"}</annotation></semantics></math>as our data points are multiplied with dot product. For vectors, this represents the similarity of these two vectors.</p>
<p>Later you will analyse this function more accurately. For now, remember that with the help of the Lagrange multipliers we have made a dual problem for minimising&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∥<!-- ∥ --></mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><msup><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><mn>2</mn></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\frac{1}{2} \|\textbf{w}\|^2\)"}</annotation></semantics></math>&nbsp;which will result in maximising the margin in SVM.</p>
<p>Now, lets say we have found the&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>α<!-- α --></mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha\)"}</annotation></semantics></math>,&nbsp;values, so given a solution to&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>α<!-- α --></mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>α<!-- α --></mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>α<!-- α --></mi><mi>n</mi></msub><mo stretchy="false">]</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha = [\alpha_1,...,\alpha_n]\)"}</annotation></semantics></math>&nbsp;the hyperplane&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{w}\)"}</annotation></semantics></math>&nbsp;the hyperplane is given as:</p>
<ul>
<li><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mo>=</mo><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{w} = \sum_{i=1}^{n} \alpha_i y_i \textbf{x}_i\)"}</annotation></semantics></math></li>
<li><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>b</mi><mo>=</mo><msub><mi>y</mi><mi>k</mi></msub><mo>−<!-- − --></mo><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>k</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(b =y_k - \sum_{i=1}^{n} \alpha_i y_i \textbf{x}_i^T \textbf{x}_k\)"}</annotation></semantics></math>&nbsp;using any&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k\)"}</annotation></semantics></math>&nbsp;such that&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mi>k</mi></msub><mo>&gt;</mo><mn>0</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_k &gt; 0\)"}</annotation></semantics></math></li>
</ul>
<span style="font-size: 15.2px;">Note that there is one&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_i\)"}</annotation></semantics></math>&nbsp;corresponding to each&nbsp;&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_i\)"}</annotation></semantics></math>. The&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_i\)"}</annotation></semantics></math>&nbsp;corresponding to each non-zero&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_i\)"}</annotation></semantics></math>&nbsp;is a&nbsp;<em>support vector</em>. Given&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>w</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(w\)"}</annotation></semantics></math>&nbsp;and&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>b</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(b\)"}</annotation></semantics></math>&nbsp;we can write classification function as:</span></div>
<div><span style="font-size: 15.2px;"><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mspace linebreak="newline"></mspace><mi>f</mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">w</mtext></mrow><mi>T</mi></msup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo>+</mo><mi>b</mi><mo>=</mo><munderover><mo>∑<!-- ∑ --></mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo>+</mo><mi>b</mi><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\\ f(\textbf{x}) = \textbf{w}^T\textbf{x} + b = \sum_{i=1}^{n} \alpha_i y_i \textbf{x}_i^T \textbf{x} + b \\"}</annotation></semantics></math>&nbsp;</span></div>
<div><span style="font-size: 15.2px;">Again note that solving for&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>α<!-- α --></mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha\)"}</annotation></semantics></math>&nbsp;and&nbsp;&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>b</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(b\)"}</annotation></semantics></math>,&nbsp;we need to use training data only in the form of&nbsp;<em>dot products&nbsp;&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>T</mi></mrow></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_{i}^{T}\textbf{x}_j\)"}</annotation></semantics></math>.&nbsp;</em>Further note that the classification function also uses a dot product between<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}\)"}</annotation></semantics></math>&nbsp;and support vectors&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_i\)"}</annotation></semantics></math>.&nbsp;We are not covering the details of the optimisation here because it requires deeper understanding of&nbsp;<em>quadratic programming</em>. However, you should know that the primal problem has computational requirements of the order&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(O(d^3)\)"}</annotation></semantics></math>,&nbsp;whereas the&nbsp;<em>dual problem</em>&nbsp;requires an order&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(O(n^3)\)"}</annotation></semantics></math>.</span></div>
<div><span style="font-size: 15.2px;"><span style="font-size: 15.2px;">Here&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>d</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(d\)"}</annotation></semantics></math>&nbsp;is the dimension of feature space and&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>n</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(n\)"}</annotation></semantics></math>&nbsp;is the number of instances in the training set. When&nbsp;&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>n</mi><mo>&gt;</mo><mi>d</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(n&gt;d\)"}</annotation></semantics></math>&nbsp;</span></span>solving the dual is more expensive than the primal. The dual problem is popular because it allow the use of arbitrary Kernels, which means SVM boundaries can be significantly nonlinear.
<h2 id="your-task">Activity</h2>
<p>Explore the following video to understand how support vector machines work. Note that there are helpful examples in Python as well.</p>
<p></p>
<div>
<p class="centerVideo"><iframe width="648" height="364" src="https://www.youtube.com/embed/TtKF996oEl8?wmode=opaque" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"></iframe></p>
<h5>This is an additional video, hosted on YouTube.</h5>
</div>
</div>
<hr>
<div><iframe class="quickNavStyle" scrolling="no" src="../00-assets/navbar/navbar.html" title="NavBar" allowfullscreen="allowfullscreen" frameborder="0"></iframe></div>
<!-- <div style="padding-top: 20px;"><a href="#" class="navrep-button" target="_parent" title="Previous" style="padding: .5rem .5rem; font-size: 12pt; float: left;"> &lt; Previous</a> <a href="#" class="navrep-button" target="_parent" title="Next" style="padding: .5rem .5rem; font-size: 12pt; float: right;">Next &gt;</a></div>
<p style="padding-bottom: 50px;"></p>
</div> -->
<p>
<script defer="defer" type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-master.js"></script>
</p>
<p>
<script>
function localProc(){
  console.log("ready!");
}
</script>
</p>
<p>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-sebe-lst-learning-design/fl-dual-delivery/js/sebe-fl-nav.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-sebe-lst-learning-design/fl-dual-delivery/js/sebe-fl.js"></script>
<script src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/jquery/jquery_3_5_1/jquery-3.5.1.min.js"></script>
<script src="../00-assets/navbar/navbar-parent.js"></script>
<script src="../00-assets/js/sit307-720.js"></script>
</p></body></html>