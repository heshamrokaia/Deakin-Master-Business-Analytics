<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager --><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager --><!-- Google Tag Manager --><script>window.dataLayer = window.dataLayer || [];window.dataLayer.push({'cmsType' : 'D2L'});</script><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N3CB');</script><!-- End Google Tag Manager -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CloudDeakin Dual Delivery Template</title>
<link rel="stylesheet" type="text/css" href="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-fl.css">
  <link rel="stylesheet" type="text/css" href="../00-assets/navbar/navbar-parent.css">
<link rel="stylesheet" type="text/css" href="../00-assets/css/sit307-720.css">

<link rel="stylesheet" href="https://s.brightspace.com/lib/fonts/0.5.0/fonts.css"><script>function lti_launch( vars, target ) {
						var query = '';
						var new_tab = false;

						for(var key in vars) {
							if(query.length == 0) {
								query += '?' + key + '=' + encodeURIComponent(vars[key]);
							}
							else {
								query += '&' + key + '=' + encodeURIComponent(vars[key]);
							}
						}

						var url = '/d2l/customization/pearsonlti/6605/Launch' + query;(target == '_blank') ? window.open( url, '_blank' ) : location.replace( url );}</script><script src="https://s.brightspace.com/lib/bsi/2024.6.211/unbundled/embeds.js?v=20.24.6.19120" type="module"></script><script>document.addEventListener('DOMContentLoaded', function() {
					window.D2L.EmbedRenderer.renderEmbeds(document.body);
				});</script><script src="https://s.brightspace.com/lib/bsi/2024.6.211/unbundled/mathjax.js?v=20.24.6.19120" type="module"></script><script>document.addEventListener('DOMContentLoaded', function() {
					if (document.querySelector('math') || /\$\$|\\\(|\\\[|\\begin{|\\ref{|\\eqref{/.test(document.body.innerHTML)) {
						document.querySelectorAll('mspace[linebreak="newline"]').forEach(elm => {
							elm.setAttribute('style', 'display: block; height: 0.5rem;');
						});

						window.D2L.MathJax.loadMathJax({
							outputScale: 1.5,
							renderLatex: true,
							enableMML3Support: false
						});
					}
				});</script><script src="https://s.brightspace.com/lib/bsi/2024.6.211/unbundled/prism.js?v=20.24.6.19120" type="module"></script><script>document.addEventListener('DOMContentLoaded', function() {
					document.querySelectorAll('.d2l-code').forEach(code => {
						window.D2L.Prism.formatCodeElement(code);
					});
				});</script><script>document.addEventListener('DOMContentLoaded', function() {
						if (document.documentElement.hasAttribute('lang')) return;
						document.documentElement.setAttribute('lang', 'en-GB'); 						
					});</script><script>document.addEventListener('DOMContentLoaded', function() {
						if (document.head.querySelector('title')) return;
						var handleAppendTitle = function(evt) {
							if (!evt || !evt.data) return;

							try {
								var data = JSON.parse(evt.data);
								if (data.handler !== 'd2l.iframe.requestPageTitle' || !data.pageTitle) return;

								window.removeEventListener('message', handleAppendTitle, false);

								var titleElm = document.createElement('title');
								titleElm.textContent = data.pageTitle;
								document.head.appendChild(titleElm);
							} catch (e) {}	
						};

						window.addEventListener('message', handleAppendTitle, false);
						window.parent.postMessage(JSON.stringify({ handler: 'd2l.iframe.requestPageTitle' }), '*');
					});</script><script>window.addEventListener('message', function(event) { 
					if( !event.data ) {
						return;
					}

					var params;
					try {
						params = JSON.parse( event.data );
					}
					catch {
						return;
					}
					if( !params.subject || params.subject !== 'lti.frameResize' ) {
						return;
					}

					const MAX_FRAME_HEIGHT = 10000
					if( !params.height || params.height < 1 || params.height > MAX_FRAME_HEIGHT ) {
						console.warn( 'Invalid height value received, aborting' );
						return;
					}
					var el = document.getElementsByTagName( 'iframe' );
					for ( var i=0; i < el.length; i++ ) {
						if( el[i].contentWindow === event.source ) {
							el[i].style.height = params.height + 'px';
							el[i].style.width = '100%';
							console.info( 'Setting iFrame height to ' + params.height );
							console.info( 'Setting iFrame width to 100%' );
						}
					}
				});</script></head><body style="color: rgb(32, 33, 34); font-family: verdana, sans-serif; font-size: 10px;"><h1>Kernel trick and non-linear SVM&nbsp;</h1>
<div>
<p>You may encounter data points which are not linearly separable.</p>
<p>If that’s the case, can we project them to another space in which they could be linearly separable?</p>
<p>Consider the following figure; in the first two cases, we can see that the data points are easily linearly separable. In the bottom left image, a single noisy data point exists but by ignoring that point we can still draw a proper linear boundary for the data.</p>
<p>In the bottom right image, since there are no linear separable lines you can see the complexity of the classification. The data points and their great numbers, suggest that these are not just noisy outputs. We probably need a&nbsp;<em>non-linear</em>&nbsp;boundary for case.</p>
<p><img src="../Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%201.png" alt="Kernel trick and non-linear SVM&nbsp;image 1" title="Kernel trick and non-linear SVM&nbsp;image 1" data-d2l-editor-default-img-style="true" style="max-width: 100%;"></p>
<p class="centerImage"><img src="../images/Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%201.png" alt="" title="" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
<h5>Figure.&nbsp;Linearly separable vs. non-linear.</h5>
<p>When faced with data points that are not linearly separable, we can try to project them into another space in which they are linearly separable?</p>
<h4 id="the-key-idea">The key idea</h4>
<p>To handle non-linearity, we can transform the features to a higher dimensional space where data is linearly separable (see figure below). This figure illustrates a 2D space in which the data points can only be separated through a non-linear curve. However by transforming these data points to a 3D space, it looks as though the data points are now linearly separable!</p>
<p></p>
<p><img src="image_20230828015323.png" data-d2l-editor-default-img-style="true" style="max-width: 100%;"></p>
<p class="centerImage"></p>
<p class="centerImage"><img src="../images/Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%202.png" alt="" title="" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
<h5>Figure.&nbsp;Transform from non-linearity to linearity.</h5>
<h3 id="kernel-trick-and-non-linear-svm">Kernel Trick and non-linear SVM</h3>
<p>SVM performs the required transformation&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi mathvariant="normal">Φ<!-- Φ --></mi><mo>:</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">→<!-- → --></mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\Phi: \textbf{x} \rightarrow \phi(\textbf{x})\)"}</annotation></semantics></math>&nbsp;<em>implicitly</em>&nbsp;by using&nbsp;<em>kernels</em>. We call this&nbsp;<em>implicit</em>&nbsp;because we do not need to compute&nbsp;</p>
<p>Since data participates (see the previous lesson) in computations only in the form of dot products, all the computations are performed via&nbsp;<em>kernels</em>.</p>
<p>The dot product of instances in transformed space becomes&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi^T(\textbf{x}_i)\phi(\textbf{x}_j)\)"}</annotation></semantics></math>&nbsp;which is directly computed through a kernel function&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j)\)"}</annotation></semantics></math>.&nbsp;&nbsp;</p>
<p>This is known as a&nbsp;<em>kernel trick</em>. There are kernels (e.g. radial basis function kernels) which allows transformations to infinite dimensional feature spaces.</p>
<h3 id="kernel-trick">Kernel Trick</h3>
<blockquote>
<p>A&nbsp;<em>kernel function</em>&nbsp;is a function that is used to compute dot products in a high dimensional feature space.</p>
</blockquote>
<h4 id="example">Example:</h4>
<p>Consider 2-dimensional vectors&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x} = [x_1,x_2]\)"}</annotation></semantics></math>.&nbsp; Let&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = (1+\textbf{x}_i^T\textbf{x}_j)^2\)"}</annotation></semantics></math>&nbsp;(a polynomial kernel).</p>
<p>We call this a polynomial kernel. Based on the definition, we need to verify that&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = \phi^T(\textbf{x}_i)\phi(\textbf{x}_j)\)"}</annotation></semantics></math>.</p>
<p>To verify this, we start with calculating the&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\((1+\textbf{x}_i^T\textbf{x}_j)^2\)"}</annotation></semantics></math>:</p>
<p><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mspace linebreak="newline"></mspace><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mn>1</mn><mo>+</mo><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow><mn>2</mn></msubsup><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><mn>2</mn><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mo>+</mo><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow><mn>2</mn></msubsup><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow><mn>2</mn></msubsup><mo>+</mo><mn>2</mn><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><mo>+</mo><mn>2</mn><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup><mo stretchy="false">[</mo><mn>1</mn><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mtext>&nbsp;</mtext><mtext>&nbsp;</mtext><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mtext>&nbsp;</mtext><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mn>1</mn></msub><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace></mstyle><annotation encoding="latex">{"version":"1.1","math":"\\ k(\textbf{x}_i,\textbf{x}_j) = (1+\textbf{x}_i^T\textbf{x}_j)^2 = 1+x_{i1}^2x_{j1}^2 + 2x_{i1}x_{j1}x_{i2}x_{j2} + x_{i2}^2x_{j2}^2 + 2x_{i1}x_{j1} + 2x_{i2}x_{j2} \\ \\ =[1\ x_{i1}^2\ \sqrt{2}x_{i1}x_{i2}\ x_{i2}^2\ \sqrt{2} x_{i1} \sqrt{2} x_{i2}]^T[1\ x_{j1}^2\ \sqrt{2} x_{j1} x_{j2}\ x_{j2}^2\ \sqrt{2} x_{j1}\ \sqrt{2}x_{j2}] \\ \\ \phi^T(\textbf{x}_i)\phi(\textbf{x}_j), \ \ where\ \phi(\textbf{x}) = [1 \ x_1^2 \ \sqrt{2} x_1x_2 \ x_2^2 \ \sqrt{2}x_1\ \sqrt{2}x_2] \\ \\"}</annotation></semantics></math></p>
<p>The above equations show that we can transform this kernel into&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi^T(\textbf{x}_i)\phi(\textbf{x}_j)\)"}</annotation></semantics></math>, format in which&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>1</mn></mrow></msub><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mn>2</mn></mrow></msub><mo stretchy="false">]</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi^T(\textbf{x}_i) = [1\ x_{i1}^2\ \sqrt{2}x_{i1}x_{i2}\ x_{i2}^2\ \sqrt{2} x_{i1} \sqrt{2} x_{i2}]\)"}</annotation></semantics></math>&nbsp;and&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mtext>&nbsp;</mtext><msubsup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow><mn>2</mn></msubsup><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>1</mn></mrow></msub><mtext>&nbsp;</mtext><msqrt><mn>2</mn></msqrt><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mn>2</mn></mrow></msub><mo stretchy="false">]</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi(\textbf{x}_j) = [1\ x_{j1}^2\ \sqrt{2} x_{j1} x_{j2}\ x_{j2}^2\ \sqrt{2} x_{j1}\ \sqrt{2}x_{j2}]\)"}</annotation></semantics></math>.&nbsp;</p>
<p>Sp&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi^T(\textbf{x}_i)\phi(\textbf{x}_j)\)"}</annotation></semantics></math>&nbsp;will results in finding the&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j)\)"}</annotation></semantics></math>.&nbsp;As you can see&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi^T(\textbf{x}_i)\)"}</annotation></semantics></math>&nbsp;and&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi(\textbf{x}_j)\)"}</annotation></semantics></math>&nbsp;and have&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mn>6</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(6\)"}</annotation></semantics></math>&nbsp;dimensions. Thus, a kernel function implicitly maps data to a&nbsp;<em>high-dimensional</em>&nbsp;space but without the need to compute&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi(\textbf{x})\)"}</annotation></semantics></math>&nbsp;explicitly.</p>
<h3 id="kernel-functions">Kernel functions</h3>
<p>What functions are kernel functions? <a href="https://en.wikipedia.org/wiki/Mercer%27s_theorem" target="_blank" rel="noopener noreferrer">Mercer’s theorem</a>&nbsp;says that:</p>
<blockquote>
<p>every positive, semi-definite and symmetric function is a kernel function.</p>
</blockquote>
<p>Kernel functions when evaluated on each pair of data instances give rise to a matrix called a&nbsp;<em>Gram matrix</em>. This matrix (denoted as&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>K</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(K\)"}</annotation></semantics></math>&nbsp;is a positive semi-definite and symmetric matrix.</p>
<p><img src="../Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%203.png" alt="Gram matrix" title="Gram matrix" data-d2l-editor-default-img-style="true" style="max-width: 100%;"></p>
<p class="centerImage"><img src="../images/Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%203.png" alt="" title="" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
<h5>Figure.&nbsp;Gram matrix</h5>
<p>Some popular kernel functions where&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msup><mi>ϕ<!-- ϕ --></mi><mi>T</mi></msup><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = \phi^T(\textbf{x}_i)\phi(\textbf{x}_j)\)"}</annotation></semantics></math>&nbsp;</p>
<p>are:</p>
<ul>
<li><strong>Linear Kernel:&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = \textbf{x}_i^T\textbf{x}_j\)"}</annotation></semantics></math>, </strong>mapping<strong>&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi(\textbf{x}) = x\)"}</annotation></semantics></math></strong></li>
<li><strong>Polynomial Kernel with degree&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>p</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(p\)"}</annotation></semantics></math>:&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mi>p</mi></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = (1+\textbf{x}_i^T\textbf{x}_j)^p\)"}</annotation></semantics></math></strong></li>
<li><strong style="font-family: Lato, sans-serif; font-size: 0.95rem;">Radial basis function (RBF) kernel:&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>k</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mo>−<!-- − --></mo><mfrac><mrow><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>−<!-- − --></mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><msup><mo fence="false" stretchy="false">∥<!-- ∥ --></mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ<!-- σ --></mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(k(\textbf{x}_i,\textbf{x}_j) = e^{-\frac{\| \textbf{x}_i - \textbf{x}_j\|^2}{2\sigma^2}}\)"}</annotation></semantics></math>&nbsp;</strong><span style="font-family: Lato, sans-serif; font-size: 0.95rem;">Mapping&nbsp;</span><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>ϕ<!-- ϕ --></mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\phi(\textbf{x})\)"}</annotation></semantics></math><span style="font-family: Lato, sans-serif; font-size: 0.95rem;">&nbsp;is infinite dimensional.</span></li>
</ul>
<p>SVM fits a&nbsp;<em>linear hyperplane</em>&nbsp;in high dimensional space; but in original space the boundaries are&nbsp;<em>non-linear</em>.</p>
<p><img src="image_20230828015541.png" width="438" height="332" style="display: block; margin-left: auto; margin-right: auto;"></p>
<p class="centerImage"><img src="../images/Kernel%20trick%20and%20non-linear%20SVM%C2%A0image%204.png" alt="" title="" style="max-width: 100%;" data-d2l-editor-default-img-style="true"></p>
<h5>Figure.&nbsp;Decision boundaries with different kernels.</h5>
<p>In the above figure, SVC means&nbsp;<em>Support Vector Classification</em>. Also you can see while using the linear kernel you are getting linear boundaries, however in polynomial kernel with degree&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mn>3</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(3\)"}</annotation></semantics></math>&nbsp;the SVM came up with curve boundaries.</p>
<p>All these outputs are on the <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set" target="_blank" rel="noopener noreferrer">Iris data set</a>&nbsp;which is a multivariate data set introduced by the British statistician and biologist Ronald Fisher.</p>
<h3 id="non-linear-svm-dual-formulation">Non-linear SVM dual formulation</h3>
<p>Let’s briefly explore the dual problem of non-linear SVM, the dual problem formulation is as follows:</p>
<ul>
<li>Find&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mn>1</mn></msub><mo>,</mo><msub><mi>α<!-- α --></mi><mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>α<!-- α --></mi><mi>n</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_1,\alpha_2,...,\alpha_n\)"}</annotation></semantics></math>&nbsp;such that&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">Q</mtext></mrow><mo stretchy="false">(</mo><mi>α<!-- α --></mi><mo stretchy="false">)</mo><mo>=</mo><mo>∑<!-- ∑ --></mo><msub><mi>α<!-- α --></mi><mi>i</mi></msub><mo>−<!-- − --></mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∑<!-- ∑ --></mo><mo>∑<!-- ∑ --></mo><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>α<!-- α --></mi><mi>j</mi></msub><msub><mi>y</mi><mi>i</mi></msub><msub><mi>y</mi><mi>j</mi></msub><mi>K</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{Q}(\alpha) = \sum \alpha_i - \frac{1}{2} \sum \sum \alpha_i \alpha_j y_i y_j K(\textbf{x}_i,\textbf{x}_j)\)"}</annotation></semantics></math>&nbsp;is maximized and&nbsp;</li>
</ul>
<span style="font-family: Lato, sans-serif; font-size: 0.95rem;"><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mstyle><mo>∑<!-- ∑ --></mo><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\sum \alpha_i y_i = 0"}</annotation></semantics></math></span></div>
<div><span style="font-family: Lato, sans-serif; font-size: 0.95rem;"><math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mi>i</mi></msub><mo>≥<!-- ≥ --></mo><mn>0</mn></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_i \geq 0\)"}</annotation></semantics></math>for all of&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>α<!-- α --></mi><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\alpha_i\)"}</annotation></semantics></math></span></div>
<div>
<ul>
<li><span style="font-family: Lato, sans-serif; font-size: 0.95rem;"><span style="font-family: Lato, sans-serif; font-size: 0.95rem;">The solution is&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>f</mi><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo><mo>=</mo><mo>∑<!-- ∑ --></mo><msub><mi>α<!-- α --></mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub><mi>K</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(f(\textbf{x}) = \sum \alpha_i y_i K(\textbf{x}_i,\textbf{x})+b\)"}</annotation></semantics></math>&nbsp;Again, the only difference is that the dot product of&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msubsup><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi><mi>T</mi></msubsup><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(\textbf{x}_i^T\textbf{x}_j\) "}</annotation></semantics></math>&nbsp;has been replaced by&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><mi>K</mi><mo stretchy="false">(</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>i</mi></msub><mo>,</mo><msub><mrow class="MJX-TeXAtom-ORD"><mtext mathvariant="bold">x</mtext></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(K(\textbf{x}_i,\textbf{x}_j)\)"}</annotation></semantics></math>.&nbsp;&nbsp;The&nbsp;<em>Optimisation techniques</em>&nbsp;for finding&nbsp;<math title="" xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mstyle><msub><mi>a</mi><mi>i</mi></msub></mstyle><annotation encoding="latex">{"version":"1.1","math":"\(a_i\)"}</annotation></semantics></math>’s remain the same.</span></span></li>
</ul>
<p align="center"><iframe src="https://deakin.au.panopto.com/Panopto/Pages/Embed.aspx?id=97c24786-6a76-44aa-85e6-afe70122a072&amp;autoplay=false&amp;offerviewer=true&amp;showtitle=true&amp;showbrand=true&amp;captions=true&amp;interactivity=all" height="405" width="720" style="border: 1px solid #464646;" allowfullscreen="" allow="autoplay" aria-label="Panopto Embedded Video Player"></iframe></p>
<table class="tableClear" style="width: 880px;">
<tbody>
<tr>
<td style="width: 59px;"></td>
<td style="width: 466.433px;"><a id="viewTranscript">View transcript</a></td>
<td style="width: 271.567px;"></td>
</tr>
</tbody>
</table>
<article class="js-transcript transcript" id="transcript-en">
<p class="transcript__para">SPEAKER: In this tutorial, we're going to show you how Kernel Trick works, or how a kernel function implicitly maps data to a high-dimensional space. First, let's define what is a kernel function. A kernel is a function that takes two vectors, xi and xj as arguments, and returns the value of the inner product of their images, phi transform of xi and phi of xj. The k of xi and xj, which is the kernel, is equal to phi transpose xi phi of xj. So let's see an example. Consider a two-dimensional vector x, which is made of x1 and x2. And let us define a kernel, xi and xj, which is a simple polynomial kernel, like 1 plus xi transpose, xj power 2.</p>
<p class="transcript__para">We need to verify that k xi, xj is following this rule in order to prove that it's a kernel. For this, let's write the equations. k xi, xj equals to 1 plus xi transpose, xj power 2. If we expand this term, we'll get these values. But the question is, is it possible for us to write this value as a form of phi transpose xi phi xj in terms of two vectors? Apparently, yes, it's possible. We can write the first one as this vector, transposed. And the second one is this vector, as you can see. But let's check.</p>
<p class="transcript__para">The dot product of these two vectors is 1 multiplied by 1, which is 1, xi1 power 2 xj1 power 2, which the product is xi2, xj1 power 2, and so on. But let's check the last one, too. So the root square of 2xi2 product root squared 2xj2 will result in 2xi2, xj2. So as you can see, we could write this kernel function in the form of phi transpose of xi, phi of xj, in which the phi of x is 1 x1 power 2 the square root of 2 x1x2, x2 power 2, again, the square root of 2 x1 and the square root of x2. So in this example, a kernel function implicitly maps the data to a high-dimensional space-- 6.</p>
<p class="transcript__para">As you can see, we have six dimensions in these vectors. And also, it's important to notice that without the need to compute the phi of x explicitly, and we just need the dot product. In the next section, you're going to see more examples about the Kernel Trick.</p>
</article>
<hr>
<div style="padding-top: 20px;"><a href="#" class="navrep-button" target="_parent" title="Previous" style="padding: .5rem .5rem; font-size: 12pt; float: left;"> &lt; Previous</a> <a href="#" class="navrep-button" target="_parent" title="Next" style="padding: .5rem .5rem; font-size: 12pt; float: right;">Next &gt;</a></div>
<p style="padding-bottom: 50px;"></p>
<p>
<script defer="defer" type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-intmedia-donotedit/templates/sebe-master.js"></script>
</p>
<p><script>
function localProc(){
  console.log("ready!");
}
</script></p>
<p>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-sebe-lst-learning-design/fl-dual-delivery/js/sebe-fl-mathjax.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-sebe-lst-learning-design/fl-dual-delivery/js/sebe-fl-nav.js"></script>
<script type="text/javascript" src="/content/enforced/384049-SEBE_LST_01/z-sebe-lst-learning-design/fl-dual-delivery/js/sebe-fl.js"></script>
</p>
</div></body></html>